import functions_framework
import flask
import logging
import tempfile
import os
from xhtml2pdf import pisa
import markdown2
from datetime import datetime
import base64

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@functions_framework.http
def generate_test_pdf(request):
    """HTTP Cloud Function to test PDF generation.
    Args:
        request (flask.Request): The request object.
    Returns:
        The response text, or any set of values that can be turned into a
        Response object using `make_response`.
    """
    # Set CORS headers for the preflight request
    if request.method == 'OPTIONS':
        # Allows GET requests from any origin with the Content-Type
        # header and caches preflight response for 3600s
        headers = {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET',
            'Access-Control-Allow-Headers': 'Content-Type',
            'Access-Control-Max-Age': '3600'
        }
        return ('', 204, headers)

    # Set CORS headers for the main request
    headers = {
        'Access-Control-Allow-Origin': '*'
    }

    try:
        logger.info("PDF generation request received")

        # Test markdown content
        markdown_content = """
# Test Document Generated by Cloud Function

## Introduction

This is a test document generated with xhtml2pdf to verify that PDF generation works correctly in a Cloud Functions environment.

## Features

* Pure Python PDF generation without system dependencies
* Works in Cloud Functions environment
* Handles Romanian characters: șțăîâ

## Sample Table

| Name | Value | Description |
|------|-------|-------------|
| Item 1 | 100 | This is item 1 |
| Item 2 | 200 | This is item 2 |
| Item 3 | 300 | This is item 3 |

## Conclusion

If you can see this document correctly formatted as a PDF, the PDF generation is working properly in the Cloud Functions environment.

Generated at: {current_time}
"""
        # Add current time
        markdown_content = markdown_content.replace("{current_time}", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))

        # Convert markdown to HTML
        html_body = markdown2.markdown(
            markdown_content,
            extras=[
                'tables',
                'fenced-code-blocks',
                'header-ids',
                'toc'
            ]
        )
        
        # Create HTML template with CSS styles
        html_template = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Test PDF Document</title>
            <style>
                @page {{
                    size: A4;
                    margin: 2cm;
                }}
                body {{
                    font-family: Arial, Helvetica, sans-serif;
                    line-height: 1.5;
                    font-size: 12pt;
                }}
                h1 {{
                    color: #003366;
                    text-align: center;
                    margin-bottom: 1cm;
                }}
                h2 {{
                    color: #003366;
                    margin-top: 0.8cm;
                    margin-bottom: 0.3cm;
                }}
                h3 {{
                    color: #003366;
                    margin-top: 0.5cm;
                    margin-bottom: 0.2cm;
                }}
                p {{
                    margin-bottom: 0.3cm;
                    text-align: justify;
                }}
                ul, ol {{
                    margin-bottom: 0.5cm;
                }}
                footer {{
                    text-align: center;
                    font-size: 9pt;
                    margin-top: 1cm;
                    border-top: 1px solid #cccccc;
                    padding-top: 0.2cm;
                }}
            </style>
        </head>
        <body>
            <div class="content">
                {html_body}
            </div>
            <footer>
                Generated by Relex PDF Function Test on {datetime.now().strftime('%Y-%m-%d at %H:%M:%S')}
            </footer>
        </body>
        </html>
        """

        # Create a temporary file for the PDF output
        with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_pdf:
            try:
                # Generate PDF
                logger.info(f"Creating PDF file at: {temp_pdf.name}")
                pdf_file = open(temp_pdf.name, "wb")
                
                # Create PDF
                pisa_status = pisa.CreatePDF(
                    html_template,
                    dest=pdf_file,
                    encoding='UTF-8'
                )
                pdf_file.close()
                
                # Check if PDF conversion was successful
                if pisa_status.err:
                    error_msg = f"PDF conversion failed: {pisa_status.err}"
                    logger.error(error_msg)
                    return flask.jsonify({"error": error_msg}), 500, headers
                
                # Check file size
                file_size = os.path.getsize(temp_pdf.name)
                logger.info(f"PDF generated successfully. File size: {file_size} bytes")
                
                # Read the PDF content
                with open(temp_pdf.name, "rb") as f:
                    pdf_content = f.read()
                
                # Return the PDF directly
                headers['Content-Type'] = 'application/pdf'
                headers['Content-Disposition'] = 'attachment; filename="test_document.pdf"'
                return pdf_content, 200, headers
                
            except Exception as e:
                error_msg = f"Error during PDF generation: {str(e)}"
                logger.error(error_msg, exc_info=True)
                return flask.jsonify({"error": error_msg}), 500, headers
            finally:
                # Clean up the temporary file
                try:
                    os.unlink(temp_pdf.name)
                    logger.info(f"Temporary file deleted: {temp_pdf.name}")
                except Exception as e:
                    logger.warning(f"Failed to delete temporary file: {str(e)}")
    
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return flask.jsonify({"error": error_msg}), 500, headers

if __name__ == "__main__":
    # For local testing
    from functions_framework import create_app
    app = create_app(target=generate_test_pdf)
    app.run(host='0.0.0.0', port=8080, debug=True) 