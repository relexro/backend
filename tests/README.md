# Relex Backend Tests

This directory contains tests for the Relex Backend application. The tests are organized as follows:

## Directory Structure

- `unit/`: Unit tests that test individual functions and components in isolation
- `integration/`: Integration tests that test the interaction between components
- `test_data/`: Persistent test data used by tests

## Running Tests

You can run tests using pytest:

```bash
# Run all tests
python -m pytest tests/

# Run only unit tests
python -m pytest tests/unit/

# Run only integration tests
python -m pytest tests/integration/

# Run tests with verbose output
python -m pytest -v tests/

# Run a specific test file
python -m pytest tests/path/to/test_file.py

# Run a specific test function
python -m pytest tests/path/to/test_file.py::test_function_name
```

## Setting Up Test Environment

To set up the test environment, create a virtual environment with Python 3.10 (the same version used in Cloud Functions) and install the required dependencies:

```bash
# Create a virtual environment with Python 3.10
python3.10 -m venv test_venv
source test_venv/bin/activate  # On Windows: test_venv\Scripts\activate

# Install dependencies
pip install -r functions/src/requirements-dev.txt
pip install -r functions/requirements.txt
```

Using Python 3.10 ensures compatibility with the Cloud Functions runtime and avoids deprecation warnings that occur with newer Python versions.

### Authentication for Integration Tests

Integration tests that interact with the deployed API require Firebase JWT tokens for authentication. The system uses three different test user personas for different test scenarios:

1. **Individual Test Account (`RELEX_TEST_JWT`)**: UID: `individual-test-acc-uid`, Email: `individual@test.org`
   - For testing endpoints as a regular user without organization membership
   
2. **Admin Test Account (`RELEX_ORG_ADMIN_TEST_JWT`)**: UID: `admin-test-acc-uid`, Email: `admin@test.org`
   - For testing endpoints as an organization administrator
   
3. **User Test Account (`RELEX_ORG_USER_TEST_JWT`)**: UID: `user-test-acc-uid`, Email: `user@test.org`
   - For testing endpoints as an organization staff member

#### Automated Token Generation (Recommended)

The easiest way to manage these tokens is using the provided token management script:

```bash
# First-time setup: Install required dependencies
pip install firebase-admin requests

# Download your Firebase service account key from Firebase Console
# (Project Settings > Service accounts > Generate new private key)
# Save it as 'firebase-service-account-key.json' in the project root

# Run the token management script
././terraform/scripts/manage_test_tokens.sh
```

This script will:
- Create or update the three test user personas in Firebase Authentication
- Generate Firebase ID tokens for each user
- Save the tokens as environment variables in `~/.zshenv`:
  - `RELEX_TEST_JWT` - For individual account testing
  - `RELEX_ORG_ADMIN_TEST_JWT` - For organization admin role testing
  - `RELEX_ORG_USER_TEST_JWT` - For organization user/staff role testing
- Automatically source the environment variables in the current shell

#### Manual Token Setup (Alternative)

If you prefer to set the tokens manually, you can use the tokens generated by the script or set them directly:

```bash
# For regular user tests (Linux/macOS)
export RELEX_TEST_JWT="your_token_for_individual@test.org"

# For organization admin tests (Linux/macOS)
export RELEX_ORG_ADMIN_TEST_JWT="your_token_for_admin@test.org"

# For organization user tests (Linux/macOS)
export RELEX_ORG_USER_TEST_JWT="your_token_for_user@test.org"

# Windows (Command Prompt) equivalents
set RELEX_TEST_JWT=your_token_for_individual@test.org
set RELEX_ORG_ADMIN_TEST_JWT=your_token_for_admin@test.org
set RELEX_ORG_USER_TEST_JWT=your_token_for_user@test.org

# Windows (PowerShell) equivalents
$env:RELEX_TEST_JWT="your_token_for_individual@test.org"
$env:RELEX_ORG_ADMIN_TEST_JWT="your_token_for_admin@test.org"
$env:RELEX_ORG_USER_TEST_JWT="your_token_for_user@test.org"
```

#### Token Expiration

Firebase JWT tokens expire after 1 hour. When tokens expire, you'll see authentication errors like "Jwt is expired". Simply refresh the tokens by running the script again:

```bash
# Generate fresh tokens
././terraform/scripts/manage_test_tokens.sh
```

#### Preparing `RELEX_TEST_JWT` for User Creation Tests

Certain integration tests, such as `test_get_me_creates_user_profile_after_operator_manual_delete` in `test_user.py`, are designed to verify the automatic creation of a user profile when a user first interacts with the system (e.g., via `GET /v1/users/me`).

To ensure these specific tests accurately cover the *creation path* using the standard `RELEX_TEST_JWT`, the Operator must manually delete the corresponding user profile from Firestore *before running such a test*.

Here's how to do it:

1.  **Obtain the `userId` (Firebase UID) from the `RELEX_TEST_JWT`**:
    If the user profile already exists, you can get its `userId` by making an authenticated request to the `/v1/users/me` endpoint. Ensure `RELEX_TEST_JWT` is set as an environment variable.

    ```bash
    # Make sure RELEX_TEST_JWT is set in your current shell session
    # Example: export RELEX_TEST_JWT="your_actual_jwt_token_here"

    USER_ID=$(curl -s -H "Authorization: Bearer $RELEX_TEST_JWT" \
    "https://relex-api-gateway-dev-mvef5dk.ew.gateway.dev/v1/users/me" | jq -r .userId)

    echo "Captured USER_ID: ${USER_ID}"
    # If the user doesn't exist yet, USER_ID might be null or the command might error.
    # In such a case, if you need the UID to ensure deletion of a non-existent user (which is fine),
    # you might need to decode the JWT locally to find the UID (often in the 'sub' or 'user_id' claim).
    ```

2.  **Delete the User from Firestore**:
    Once you have the `USER_ID` (Firebase UID), use the Firebase CLI to delete the user document from the `users` collection. This command forcibly deletes the document without further prompts due to the `-f` flag.

    ```bash
    # Ensure you are authenticated with Firebase CLI and have selected the correct project (relexro)
    # Example: firebase login; firebase use relexro

    if [ -n "$USER_ID" ] && [ "$USER_ID" != "null" ]; then
      echo "Attempting to delete user document: users/${USER_ID} from project relexro..."
      firebase firestore:delete "users/${USER_ID}" --project=relexro -f --yes
      echo "Deletion command executed for users/${USER_ID}."
    else
      echo "USER_ID is empty or null. Skipping Firestore deletion. If a user profile for RELEX_TEST_JWT needs deletion, obtain its UID and run the delete command manually."
    fi
    ```

By performing these steps before running tests like `test_get_me_creates_user_profile_after_operator_manual_delete`, you ensure the test accurately verifies the profile creation logic. For other tests that expect the user associated with `RELEX_TEST_JWT` to exist, this deletion step should not be performed.

### Integration Test Environment Setup

#### API Base URL Resolution

Integration tests automatically determine the API base URL required to connect to the deployed backend. The `api_base_url` fixture in `tests/conftest.py` implements the following logic:

1.  It first attempts to read the `api_gateway_url` from the `docs/terraform_outputs.log` file. If found, the base URL is constructed as `https://<api_gateway_url_from_file>/v1`.
2.  If `docs/terraform_outputs.log` is not found, or if the `api_gateway_url` key is missing within it, the fixture will attempt to use the value of the `RELEX_API_BASE_URL` environment variable.
3.  If neither method yields a base URL, integration tests that depend on this fixture will be skipped.

**Action Required**:
* Ensure `docs/terraform_outputs.log` is kept up-to-date after any relevant Terraform deployments.
* Alternatively, or as a fallback, ensure the `RELEX_API_BASE_URL` environment variable is correctly set in your test execution environment (e.g., `export RELEX_API_BASE_URL=https://your-api-gateway-id.ew.gateway.dev/v1`).

#### Prerequisites for Payment Integration Tests

Specific payment integration tests, such as `test_create_checkout_session` in `tests/integration/test_payments.py`, have additional prerequisites:

1.  **Stripe Price ID Environment Variable**: An environment variable like `STRIPE_PRICE_ID_INDIVIDUAL_MONTHLY` must be set with a valid Stripe Price ID (e.g., `price_xxxxxxxxxxxxxx`). This ID is used by the test and backend to refer to a specific Stripe price object, often looked up via an internal map in `functions/src/payments.py` which links a `planId` like `"individual_monthly"` to this environment variable.

2.  **`planId` in Test Payload**: The test payload for creating checkout sessions (e.g., for `test_create_checkout_session`) sends a `planId` (e.g., `"individual_monthly"`). This `planId` must be a recognized key within an internal map in the `functions/src/payments.py` backend code.

3.  **Firestore `plans` Document for Webhook Processing**: For subsequent webhook processing related to the plan identified by `planId` (e.g., `"individual_monthly"`), a corresponding document must exist in the Firestore `plans` collection.
    * **Document ID**: Must match the `planId` (e.g., `individual_monthly`).
    * **Required Fields (example for `individual_monthly`):**
        * `caseQuotaTotal` (Number): The total case quota granted by this plan (this is read by webhook handlers).
        * `stripePriceId` (String): The Stripe Price ID (e.g., `price_1RRUysCQ8cBrpIHal3AOk6JA`). Useful for reference and consistency, even if not directly used by the `create_checkout_session` endpoint to find the price.
        * Other plan-specific metadata (e.g., `name`, `description`).

Ensure these environment variables are set and Firestore data is configured by the Operator before running these payment tests to avoid test failures related to setup.

## Writing Tests

When writing tests, follow these guidelines:

1. Place unit tests in the `unit/` directory
2. Place integration tests in the `integration/` directory
3. Name test files with the `test_` prefix
4. Name test functions with the `test_` prefix
5. Use the `pytest` framework for writing tests
6. Keep test data in the `test_data/` directory

### Example Test

```python
# Simple test function
def test_something():
    assert 1 + 1 == 2

# Test function with fixture
def test_with_fixture(api_base_url):
    # The API Gateway URL is found in docs/terraform_outputs.log
    assert api_base_url.startswith("https://relex-api-gateway-dev")
```

## API Specification Reference

When writing integration tests, refer to the following resources for API endpoint details:

- `docs/api.md`: High-level, human-readable API documentation
- `terraform/openapi_spec.yaml`: Authoritative OpenAPI v3 specification

These documents define the available endpoints, methods, request/response bodies, and authentication requirements.

### API Gateway URL

The API is accessed via the default Google Cloud API Gateway URL, not the custom domain. To find this URL:

1. Check the `docs/terraform_outputs.log` file after deployment
2. Look for the `api_gateway_url` key (e.g., `relex-api-gateway-dev-mvef5dk.ew.gateway.dev`)
3. Use this URL as the base for all API requests in tests

### Health Checks

When testing API endpoints, you can verify the health of a function by including the `X-Google-Health-Check` header:

```python
response = requests.get(
    f"{api_base_url}/endpoint/path",
    headers={"X-Google-Health-Check": "true"}
)
assert response.status_code == 200
assert response.json()["status"] == "healthy"
```

Note that health checks are implemented using the `X-Google-Health-Check` header rather than specific paths like `/_ah/health`.

Example:
```python
# In conftest.py or similar
@pytest.fixture
def api_base_url():
    # Read from terraform_outputs.log or use environment variable
    return "https://relex-api-gateway-dev-mvef5dk.ew.gateway.dev"
```

Note: The custom domain `api-dev.relex.ro` is not currently the active endpoint for the API Gateway.

## Test Data Management

Integration tests interact with a live (dev) environment and may create, modify, or delete data. Follow these guidelines for test data management:

1. **Clean up after tests**: Tests should clean up any data they create. Use `pytest` fixtures with proper teardown to ensure cleanup.

2. **Isolate test data**: Use unique identifiers (e.g., prefixes like `test_`) for test data to avoid conflicts with real data.

3. **Use helper fixtures**: Common setup/teardown tasks should be implemented as fixtures in `tests/conftest.py` or helper functions in `tests/helpers/`.

4. **Document dependencies**: If a test requires specific pre-existing data, document this clearly in the test docstring.

Example of a test with proper setup and teardown:

```python
@pytest.fixture
def test_organization(api_client):
    """Create a test organization and clean it up after the test."""
    # Setup
    org_data = {
        "name": f"Test Org {uuid.uuid4()}",
        "type": "legal_firm"
    }
    response = api_client.post("/organizations", json=org_data)
    org_id = response.json()["id"]

    yield org_id

    # Teardown
    api_client.delete(f"/organizations/{org_id}")

def test_get_organization(api_client, test_organization):
    """Test getting an organization by ID."""
    org_id = test_organization
    response = api_client.get(f"/organizations/{org_id}")
    assert response.status_code == 200
    assert response.json()["id"] == org_id
```